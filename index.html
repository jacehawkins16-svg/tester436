<script>
    // Define APIs and DOM elements
    const IP_API_URL = 'https://ipinfo.io/json';
    const COUNTRY_NAME_API = 'https://restcountries.com/v3.1/alpha/';
    const FLAG_API_BASE = 'https://flagsapi.com/';
    const infoCard = document.getElementById('info-card'); // Main report container

    const dataElements = {
        // ... (dataElements definition remains the same) ...
        // UI Modal Elements
        nameModal: document.getElementById('name-modal'),
        userNameInput: document.getElementById('userNameInput'),
        submitNameBtn: document.getElementById('submitNameBtn'),

        // Network Identity
        ip: document.getElementById('ip'),
        org: document.getElementById('org'),
        asn: document.getElementById('asn'), 
        
        // Geographic Location
        countryCodeSpan: document.getElementById('country-code'),
        countryFullNameSpan: document.getElementById('country-full-name'),
        flagImage: document.getElementById('flag-image'),
        region: document.getElementById('region'),
        city: document.getElementById('city'),
        zip: document.getElementById('zip'),
        coords: document.getElementById('coords'),
        
        // Client Device & Browser 
        clientName: document.getElementById('clientName'), 
        os: document.getElementById('os'),
        browser: document.getElementById('browser'),
        resolution: document.getElementById('resolution'),
        deviceType: document.getElementById('deviceType'),

        // Network Capabilities & Time 
        timezone: document.getElementById('timezone'),
        localTime: document.getElementById('localTime'),
        connectionSpeed: document.getElementById('connectionSpeed'),
        browserLanguage: document.getElementById('browserLanguage'),

        // Raw
        userAgentRaw: document.getElementById('userAgentRaw'),
    };
    const loadingDiv = document.getElementById('loading');
    const errorDiv = document.getElementById('error');
    const errorMessage = document.getElementById('error-message');
    const contentGrid = document.getElementById('content-grid'); 

    const labelClass = 'data-line-label';
    const valueClass = 'result-value-text';

    /**
     * Utility function to format the output string for text-only fields.
     */
    function formatTextLine(label, value) {
        return `
            <span class="${labelClass}">${label}:</span><br>
            <div class="country-value-wrapper"> 
                <span class="${valueClass}">${value}</span> 
            </div>
        `;
    }
    
    /**
     * Simple function to determine the OS based on the User Agent String.
     */
    function getOperatingSystem(userAgent) {
        if (userAgent.includes("Win")) return "Windows";
        if (userAgent.includes("Android")) return "Android";
        if (userAgent.includes("Mac")) return "macOS (Apple)";
        if (userAgent.includes("Linux")) return "Linux";
        if (userAgent.includes("CrOS")) return "Chrome OS";
        if (userAgent.includes("iPhone") || userAgent.includes("iPad")) return "iOS (Apple)";
        return "Unknown/Other";
    }

    /**
     * Simple function to determine the browser based on the User Agent String.
     */
    function getBrowser(userAgent) {
        let browser = "Unknown";
        let version = "";

        if (userAgent.includes("Chrome") && !userAgent.includes("Edg")) {
            browser = "Chrome";
            version = userAgent.match(/Chrome\/(\d+)/)?.[1] || "";
        } else if (userAgent.includes("Firefox")) {
            browser = "Firefox";
            version = userAgent.match(/Firefox\/(\d+)/)?.[1] || "";
        } else if (userAgent.includes("Safari") && !userAgent.includes("Chrome")) {
            browser = "Safari";
            version = userAgent.match(/Version\/(\d+)/)?.[1] || "";
        } else if (userAgent.includes("Edg")) {
            browser = "Edge";
            version = userAgent.match(/Edg\/(\d+)/)?.[1] || "";
        } else if (userAgent.includes("MSIE") || userAgent.includes("Trident")) {
            browser = "Internet Explorer";
        }
        return version ? `${browser} (v${version})` : browser;
    }

    /**
     * Gathers and populates client-side device and capability data.
     * Now RETURNS the collected data object.
     */
    function getDeviceData(clientName) {
        const userAgent = navigator.userAgent;
        const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
        
        // --- 1. Collect Data Object ---
        const deviceData = {
            clientName: clientName || "Guest User",
            os: getOperatingSystem(userAgent),
            browser: getBrowser(userAgent),
            resolution: `${window.screen.width}x${window.screen.height}`,
            deviceType: /Mobi|Android|iPhone|iPad|Windows Phone/i.test(userAgent) ? 'Mobile/Tablet' : 'Desktop',
            connectionSpeed: (connection && connection.effectiveType ? connection.effectiveType.toUpperCase() : 'N/A') + (connection && connection.downlink ? ` (${connection.downlink.toFixed(1)} Mbps)` : ''),
            browserLanguage: navigator.language || 'N/A',
            localTime: new Date().toLocaleTimeString(navigator.language, { 
                weekday: 'short', day: 'numeric', month: 'short', 
                year: 'numeric', hour: '2-digit', minute: '2-digit' 
            }),
            userAgentRaw: userAgent
        };

        // --- 2. Update DOM (Existing logic) ---
        dataElements.clientName.innerHTML = formatTextLine('Name', deviceData.clientName); 
        dataElements.os.innerHTML = formatTextLine('Operating System', deviceData.os);
        dataElements.browser.innerHTML = formatTextLine('Browser', deviceData.browser);
        dataElements.resolution.innerHTML = formatTextLine('Resolution', deviceData.resolution);
        dataElements.deviceType.innerHTML = formatTextLine('Device Type', deviceData.deviceType);
        dataElements.connectionSpeed.innerHTML = formatTextLine('Connection Speed', deviceData.connectionSpeed);
        dataElements.browserLanguage.innerHTML = formatTextLine('Language', deviceData.browserLanguage);
        dataElements.localTime.innerHTML = formatTextLine('Local Time', deviceData.localTime);
        dataElements.userAgentRaw.textContent = deviceData.userAgentRaw;
        
        return deviceData;
    }

    /**
     * Sends the collected report data to the alternate server endpoint.
     */
    async function sendDataToAlternateWebsite(dataObject) {
        // >>> IMPORTANT: REPLACE THIS URL WITH YOUR ALTERNATE WEBSITE'S API ENDPOINT
        const TARGET_URL = 'https://YOUR_ALTERNATE_WEBSITE.com/api/user-verification'; 

        try {
            const response = await fetch(TARGET_URL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(dataObject),
            });

            if (!response.ok) {
                console.error('Server Data Transfer Failed:', response.statusText);
            } else {
                const result = await response.json();
                console.log('Server verification process successful. Server response:', result);
                // The server response can contain a status or a message you can use here.
            }
        } catch (error) {
            console.error('Error sending data to alternate website. Check your TARGET_URL and server access:', error);
        }
    }
    
    // ... (showContent, displayError, updateCountryDetails remain the same) ...

    /**
     * Hides the loading spinner and shows the content grid with a smooth rise/fade effect.
     */
    function showContent() {
        loadingDiv.classList.add('hidden');
        // 1. Show the content container (removes 'hidden')
        contentGrid.classList.remove('hidden'); 
        
        // 2. Use a small timeout to ensure the browser registers the 'hidden' removal 
        // before we remove the starting transition classes (opacity-0, scale-98, translate-y-8).
        setTimeout(() => {
            contentGrid.classList.remove('opacity-0', 'scale-98', 'translate-y-8');
        }, 10); 
    }

    /**
     * Displays an error message and logs it to the console, then shows the grid with error values.
     */
    function displayError(msg, clientName) {
        loadingDiv.classList.add('hidden');
        errorDiv.classList.remove('hidden');
        errorMessage.textContent = msg;
        console.error('Network Report Error:', msg);
        
        // Fill placeholders with error indicator
        Object.keys(dataElements).forEach(key => {
            const el = dataElements[key];
            if (el && key !== 'countryCodeSpan' && key !== 'countryFullNameSpan' && key !== 'flagImage' && key !== 'userAgentRaw') {
                const label = key.charAt(0).toUpperCase() + key.slice(1).replace(/([A-Z])/g, ' $1');
                el.innerHTML = formatTextLine(label, 'Failed');
            }
        });
        dataElements.countryFullNameSpan.textContent = 'Failed';
        dataElements.countryCodeSpan.textContent = '(Fail)';
        dataElements.userAgentRaw.textContent = 'Failed to retrieve User Agent.';
        
        // Ensure client name is still displayed even if API fetch fails
        getDeviceData(clientName); 

        // Show the (now error-filled) content grid with the transition effect
        contentGrid.classList.remove('hidden'); 
        setTimeout(() => {
            contentGrid.classList.remove('opacity-0', 'scale-98', 'translate-y-8');
        }, 10);
    }
    
    /**
     * Fetches the full country name based on the country code.
     */
    async function updateCountryDetails(code) {
        if (!code || code === 'N/A') {
            dataElements.countryFullNameSpan.textContent = 'N/A';
            dataElements.countryCodeSpan.textContent = '';
            return;
        }

        // 1. Set Flag URL
        dataElements.flagImage.src = `${FLAG_API_BASE}${code}/flat/64.png`;

        // 2. Set Code
        dataElements.countryCodeSpan.textContent = `(${code})`; 
        dataElements.countryFullNameSpan.textContent = 'Loading...';

        // 3. Fetch Full Name
        try {
            const nameResponse = await fetch(`${COUNTRY_NAME_API}${code}?fields=name`);
            if (nameResponse.ok) {
                const nameData = await nameResponse.json();
                dataElements.countryFullNameSpan.textContent = nameData?.name?.common || code;
            } else {
                dataElements.countryFullNameSpan.textContent = code;
            }
        } catch (e) {
            dataElements.countryFullNameSpan.textContent = code;
            console.warn('Could not fetch full country name:', e);
        }
    }

    /**
     * Fetches and displays the public IP and geolocation data with retry logic.
     * Includes assembly and transmission of the final data object.
     */
    async function fetchGeolocationData(clientName) {
        const MAX_RETRIES = 3;
        let lastError = null;

        async function fetchWithRetry(url, maxAttempts) {
            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return await response.json();
                } catch (error) {
                    lastError = error;
                    if (attempt < maxAttempts) {
                        const delay = Math.pow(2, attempt) * 1000;
                        // Implement exponential backoff delay
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
            }
            throw lastError;
        }

        // 1. Fetch client-side device data (and populate DOM)
        const deviceData = getDeviceData(clientName);

        try {
            // 2. Fetch IP and primary data with retry
            const data = await fetchWithRetry(IP_API_URL, MAX_RETRIES);
            
            // 3. Assemble Full Report Data Object
            const reportData = {
                ...deviceData, // Client Name, OS, Browser, etc.
                ipAddress: data.ip || 'N/A',
                organization: data.org || 'N/A',
                asn: data.asn || 'N/A',
                country: data.country || 'N/A',
                region: data.region || 'N/A',
                city: data.city || 'N/A',
                zipCode: data.postal || 'N/A',
                coordinates: data.loc || 'N/A',
                ipTimezone: data.timezone || 'N/A',
                // Note: The public IP (data.ip) is used for the log, not the user's input name.
            };
            
            // 4. Update CORE NETWORK IDENTITY fields
            dataElements.ip.innerHTML      = formatTextLine('IP Address', data.ip || 'N/A');
            dataElements.org.innerHTML     = formatTextLine('ISP / Organization', data.org || 'N/A');
            dataElements.asn.innerHTML     = formatTextLine('ASN', data.asn || 'N/A');
            
            // 5. Update GEOGRAPHIC LOCATION fields
            dataElements.region.innerHTML  = formatTextLine('State/Region', data.region || 'N/A');
            dataElements.city.innerHTML    = formatTextLine('City', data.city || 'N/A');
            dataElements.zip.innerHTML     = formatTextLine('Zip Code', data.postal || 'N/A');
            dataElements.coords.innerHTML  = formatTextLine('Coordinates', data.loc || 'N/A');

            // 6. Update NETWORK CAPABILITIES & TIME fields (IP specific)
            dataElements.timezone.innerHTML = formatTextLine('IP Timezone', data.timezone || 'N/A');
            
            // 7. Fetch and display country-specific details (flag and full name)
            const countryCode = data.country || 'N/A';
            await updateCountryDetails(countryCode);

            // 8. Send the data to your alternate server (THE NEW STEP)
            await sendDataToAlternateWebsite(reportData);

            showContent();

        } catch (error) {
            // Pass clientName to displayError to ensure it's still shown
            displayError(`Could not retrieve geolocation data after multiple attempts. Details: ${error ? error.message : 'Unknown error.'}`, clientName);
        }
    }

    /**
     * Initialization function: Controls the Modal flow.
     */
    window.onload = function() {
        const modal = dataElements.nameModal;
        const input = dataElements.userNameInput;
        const submitBtn = dataElements.submitNameBtn;
        
        // Show the modal after a brief delay for body background to load
        setTimeout(() => {
             modal.classList.remove('opacity-0');
        }, 100);

        function handleSubmission() {
            let clientName = input.value.trim();
            if (!clientName) {
                clientName = "Guest User"; 
            }

            // Smoothly hide the modal
            const modalContent = document.getElementById('modal-content');
            modalContent.classList.add('scale-75', 'opacity-0');
            modal.classList.add('opacity-0');

            // Show the main content card
            infoCard.classList.remove('hidden');

            setTimeout(() => {
                modal.classList.add('hidden'); // Fully hide the modal element
            }, 500); // Wait for the transition duration

            // Proceed with the report generation after a short delay
            const minDelay = 500; 
            const maxDelay = 1500;
            const randomDelay = Math.floor(Math.random() * (maxDelay - minDelay + 1)) + minDelay;
            
            setTimeout(() => {
                fetchGeolocationData(clientName);
            }, randomDelay);
        }

        // Event listener for button click
        submitBtn.addEventListener('click', handleSubmission);
        
        // Event listener for Enter key
        input.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                handleSubmission();
            }
        });
        
        // Focus on the input field for immediate typing
        input.focus();
    };
</script>
