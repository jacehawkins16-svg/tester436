<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vibrant Retro Tetris</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* FONT IMPORT: SuperJoyful */
        /* NOTE: The font URL below is a placeholder and may not load in all environments. */
        @font-face {
            font-family: 'SuperJoyful';
            src: url('https://jaces-games.vercel.app/SuperJoyful-lxwPq.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
        }
        
        /* Custom CSS for the Game Board and Blocks */
        body {
            font-family: 'SuperJoyful', sans-serif;
            background-color: #1e1b4b; /* Deep Indigo Background */
            background-image: radial-gradient(#3a3375 1px, transparent 0);
            background-size: 30px 30px;
        }
        .game-container {
            display: flex;
            gap: 2.5rem;
            align-items: flex-start;
            padding: 2rem;
        }
        #tetrisCanvas {
            /* Board background changed to a deep, dark purple-blue */
            background: #1F1A33; 
            border: 8px solid #6d28d9; /* Indigo 700 Border */
            box-shadow: 0 0 30px rgba(109, 40, 217, 0.7); /* Neon Shadow */
            border-radius: 12px;
            image-rendering: pixelated;
        }
        .info-panel {
            min-width: 200px;
            max-width: 250px;
            background: rgba(31, 26, 51, 0.8); /* Semi-transparent background */
            border: 4px solid #f97316; /* Orange 600 Border */
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 0 15px rgba(249, 115, 22, 0.5);
            color: #f97316;
        }
        .text-neon {
            color: #a78bfa; /* Violet 400 */
            text-shadow: 0 0 5px #a78bfa;
        }
        .button-neon {
            background-color: #f97316;
            color: #1e1b4b;
            font-weight: bold;
            border-radius: 8px;
            padding: 0.5rem 1rem;
            transition: all 0.15s ease-in-out;
            box-shadow: 0 4px #c2410c; /* Darker orange shadow */
        }
        .button-neon:hover {
            background-color: #fb923c;
            box-shadow: 0 2px #c2410c;
            transform: translateY(2px);
        }
        .button-neon:active {
            background-color: #c2410c;
            box-shadow: none;
            transform: translateY(4px);
        }
        .modal-neon {
            background: #1F1A33;
            border: 4px solid #f97316;
            box-shadow: 0 0 20px rgba(249, 115, 22, 0.7);
        }
        .input-neon {
            background: #3730a3;
            border: 2px solid #a78bfa;
            color: white;
            padding: 0.5rem;
            border-radius: 6px;
        }
        .message-box {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            padding: 15px 30px;
            border-radius: 8px;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transition: opacity 0.5s, transform 0.5s;
        }
        .message-box.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }
        .message-box.success {
            background-color: #10b981; /* Emerald 500 */
            color: white;
        }
        .message-box.error {
            background-color: #ef4444; /* Red 500 */
            color: white;
        }
        /* Custom scrollbar for better aesthetics */
        .info-panel::-webkit-scrollbar {
            width: 8px;
        }
        .info-panel::-webkit-scrollbar-thumb {
            background: #f97316;
            border-radius: 4px;
        }
        .info-panel::-webkit-scrollbar-track {
            background: #1F1A33;
        }
    </style>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, query, orderBy, limit, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // Expose Firebase functions and objects globally for use in the main script block
        window.initializeFirebaseApp = initializeApp;
        window.getFirebaseAuth = getAuth;
        window.firebaseSignInAnonymously = signInAnonymously;
        window.firebaseSignInWithCustomToken = signInWithCustomToken;
        window.onFirebaseAuthStateChanged = onAuthStateChanged;
        window.firebaseGetFirestore = getFirestore;
        window.firebaseDoc = doc;
        window.firebaseSetDoc = setDoc;
        window.firebaseOnSnapshot = onSnapshot;
        window.firebaseCollection = collection;
        window.firebaseQuery = query;
        window.firebaseOrderBy = orderBy;
        window.firebaseLimit = limit;
        window.firebaseCreateUserWithEmailAndPassword = createUserWithEmailAndPassword;
        window.firebaseSignInWithEmailAndPassword = signInWithEmailAndPassword;
        window.firebaseSignOut = signOut;
        window.firebaseSetLogLevel = setLogLevel;
        window.firebaseGetDocs = getDocs;
    </script>
</head>
<body class="p-4 flex items-center justify-center min-h-screen">

    <div id="app" class="game-container flex-col lg:flex-row">
        
        <div class="info-panel order-2 lg:order-1 self-stretch">
            <h2 class="text-2xl font-bold mb-4 text-center text-neon">GAME STATS</h2>
            <div class="space-y-3">
                <p class="text-xl">Score: <span id="score" class="font-bold">0</span></p>
                <p class="text-xl">Lines: <span id="lines" class="font-bold">0</span></p>
                <p class="text-xl">Level: <span id="level" class="font-bold">1</span></p>
            </div>
            
            <hr class="my-4 border-t-2 border-orange-600">
            
            <h3 class="text-2xl font-bold mb-4 text-center text-neon">HIGH SCORES</h3>
            <div class="space-y-3">
                <p class="text-lg">Your High Score: <span id="userHighScore" class="font-bold text-yellow-300">N/A</span></p>
                <div class="flex items-center justify-between text-lg">
                    <span>Global Top Score:</span>
                    <span id="globalTopScore" class="font-bold text-green-300">N/A</span>
                </div>
            </div>

            <hr class="my-4 border-t-2 border-orange-600">

            <h3 class="text-2xl font-bold mb-4 text-center text-neon">NEXT PIECE</h3>
            <div id="nextPieceContainer" class="flex justify-center p-2">
                <canvas id="nextPieceCanvas" width="80" height="80"></canvas>
            </div>
            
            <div class="mt-6 flex flex-col space-y-3">
                <button id="startButton" class="button-neon">START GAME</button>
                <button id="pauseButton" class="button-neon hidden">PAUSE GAME</button>
                <button id="restartButton" class="button-neon">RESTART</button>
            </div>
        </div>

        <div class="order-1 lg:order-2">
            <canvas id="tetrisCanvas" width="300" height="600" class="shadow-2xl"></canvas>
        </div>

        <div class="info-panel order-3 self-stretch overflow-y-auto max-h-[600px]">
            <h2 class="text-2xl font-bold mb-4 text-center text-neon">PLAYER & LEADERBOARD</h2>
            
            <div id="authStatus" class="text-center mb-4">
                <p class="text-lg">Status: <span id="authStatusText" class="font-bold">Loading...</span></p>
                <div class="flex items-center justify-center space-x-2 text-sm text-gray-400">
                    <p>User ID: </p><code id="userIdDisplay" class="truncate max-w-[150px] text-xs bg-indigo-900 px-1 py-0.5 rounded"></code>
                </div>
            </div>

            <div id="authButtons" class="flex flex-col space-y-3 mb-4">
                <button id="loginModalButton" class="button-neon">Log In / Sign Up</button>
                <button id="logoutButton" class="button-neon hidden">Log Out</button>
            </div>

            <hr class="my-4 border-t-2 border-orange-600">

            <h3 class="text-2xl font-bold mb-4 text-center text-neon">GLOBAL TOP 10</h3>
            <ul id="leaderboardList" class="space-y-2 text-lg">
                <li class="flex justify-between items-center text-gray-400">
                    <span>Loading...</span>
                </li>
            </ul>
        </div>
    </div>
    
    <div id="messageBox" class="message-box"></div>

    <div id="authModal" class="fixed inset-0 bg-black bg-opacity-75 z-50 flex items-center justify-center hidden">
        <div class="modal-neon w-full max-w-sm p-6 rounded-lg">
            <div class="flex justify-between items-center mb-4">
                <h2 id="authModalTitle" class="text-2xl font-bold text-neon">Log In</h2>
                <button id="closeAuthModal" class="text-neon hover:text-white text-3xl leading-none">&times;</button>
            </div>
            
            <p id="authMessage" class="text-center py-2 mb-4 rounded hidden"></p>

            <form id="loginForm" class="space-y-4">
                <input type="email" id="loginEmail" placeholder="Email" class="input-neon w-full" required>
                <input type="password" id="loginPassword" placeholder="Password" class="input-neon w-full" required>
                <button type="submit" id="loginSubmit" class="button-neon w-full">Log In</button>
                <p class="text-center text-sm text-gray-300">
                    Don't have an account? <button type="button" id="switchToSignUp" class="text-neon hover:underline">Sign Up</button>
                </p>
            </form>

            <form id="signUpForm" class="space-y-4 hidden">
                <input type="email" id="signUpEmail" placeholder="Email" class="input-neon w-full" required>
                <input type="password" id="signUpPassword" placeholder="Password (min 6 characters)" class="input-neon w-full" required>
                <button type="submit" id="signUpSubmit" class="button-neon w-full">Create Account</button>
                <p class="text-center text-sm text-gray-300">
                    Already have an account? <button type="button" id="switchToLogin" class="text-neon hover:underline">Log In</button>
                </p>
            </form>
        </div>
    </div>

    <script>
        // --- GLOBALS ---
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30; // 30px per block
        const CANVAS_WIDTH = COLS * BLOCK_SIZE;
        const CANVAS_HEIGHT = ROWS * BLOCK_SIZE;

        const canvas = document.getElementById('tetrisCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        const nextCanvas = document.getElementById('nextPieceCanvas');
        const nextCtx = nextCanvas.getContext('2d');
        const NEXT_PREVIEW_SIZE = 4; // 4x4 grid for next piece preview
        nextCanvas.width = BLOCK_SIZE * NEXT_PREVIEW_SIZE;
        nextCanvas.height = BLOCK_SIZE * NEXT_PREVIEW_SIZE;

        let board;
        let currentPiece;
        let nextPiece;
        let score = 0;
        let lines = 0;
        let level = 1;
        let gameLoop;
        let isPaused = false;
        let isGameOver = false;

        // Firebase Globals
        let db;
        let auth;
        let userId = null;
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-tetris-app-id';
        
        // ** FIREBASE CONFIGURATION - FIX FOR API KEY ERROR **
        // ⚠️ INSTRUCTION: You MUST replace this MOCK_FIREBASE_CONFIG with the actual configuration 
        // from your Firebase project to enable real database features and fix the 'api-key-not-valid' error.
        // Get this from your Firebase project settings.
        const FALLBACK_FIREBASE_CONFIG = {
            apiKey: "YOUR_API_KEY_HERE",
            authDomain: "YOUR_AUTH_DOMAIN_HERE",
            projectId: "YOUR_PROJECT_ID_HERE",
            storageBucket: "YOUR_STORAGE_BUCKET_HERE",
            messagingSenderId: "YOUR_MESSAGING_SENDER_ID_HERE",
            appId: "YOUR_APP_ID_HERE",
        };
        
        // Use provided config or fallback to placeholder config if unavailable
        const firebaseConfig = typeof __firebase_config !== 'undefined' && __firebase_config 
                               ? JSON.parse(__firebase_config) 
                               : FALLBACK_FIREBASE_CONFIG;

        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Flag to check if Firebase is likely to work (i.e., not using the placeholder config)
        const isFirebaseConfigValid = firebaseConfig.apiKey !== 'YOUR_API_KEY_HERE';

        const SCORE_PER_LINE = [0, 40, 100, 300, 1200]; // Scores for 0, 1, 2, 3, 4 lines cleared
        const LINES_PER_LEVEL = 10;
        
        // Piece shapes and colors
        const PIECES = [
            // I piece (Cyan)
            { shape: [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]], color: '#00ffff' }, 
            // J piece (Blue)
            { shape: [[1, 0, 0], [1, 1, 1], [0, 0, 0]], color: '#0000ff' }, 
            // L piece (Orange)
            { shape: [[0, 0, 1], [1, 1, 1], [0, 0, 0]], color: '#ff7f00' }, 
            // O piece (Yellow)
            { shape: [[1, 1], [1, 1]], color: '#ffff00' }, 
            // S piece (Green)
            { shape: [[0, 1, 1], [1, 1, 0], [0, 0, 0]], color: '#00ff00' }, 
            // T piece (Purple)
            { shape: [[0, 1, 0], [1, 1, 1], [0, 0, 0]], color: '#800080' }, 
            // Z piece (Red)
            { shape: [[1, 1, 0], [0, 1, 1], [0, 0, 0]], color: '#ff0000' }  
        ];

        // --- GAME LOGIC FUNCTIONS ---
        
        function startGame() {
            if (gameLoop) {
                cancelAnimationFrame(gameLoop);
                clearInterval(gameLoop); // Clear interval if it was running
            }
            
            board = createBoard();
            score = 0;
            lines = 0;
            level = 1;
            isPaused = false;
            isGameOver = false;

            document.getElementById('score').textContent = score;
            document.getElementById('lines').textContent = lines;
            document.getElementById('level').textContent = level;
            document.getElementById('startButton').classList.add('hidden');
            document.getElementById('pauseButton').classList.remove('hidden');
            document.getElementById('pauseButton').textContent = 'PAUSE GAME';
            
            // Initialize pieces
            nextPiece = randomPiece();
            spawnNewPiece();
            
            // Start the animation loop
            lastTime = performance.now();
            requestAnimationFrame(gameTick);
        }

        function createBoard() {
            return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        }

        function randomPiece() {
            const index = Math.floor(Math.random() * PIECES.length);
            const piece = PIECES[index];
            return {
                shape: piece.shape,
                color: piece.color,
                x: Math.floor(COLS / 2) - Math.floor(piece.shape[0].length / 2),
                y: 0 
            };
        }

        function drawBlock(x, y, color, context = ctx) {
            if (x < 0 || x >= COLS || y < 0 || y >= ROWS) return;

            context.fillStyle = color;
            context.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            
            // Add gradient/shadow for visual pop
            context.strokeStyle = 'rgba(0,0,0,0.2)';
            context.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            context.fillStyle = 'rgba(255, 255, 255, 0.2)';
            context.fillRect(x * BLOCK_SIZE + 3, y * BLOCK_SIZE + 3, BLOCK_SIZE - 6, BLOCK_SIZE - 6);
        }

        function drawBoard() {
            // Clear canvas
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // Draw background and grid (optional, but good for alignment)
            ctx.fillStyle = '#1F1A33';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Draw existing blocks on the board
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    if (board[r][c]) {
                        drawBlock(c, r, board[r][c]);
                    }
                }
            }

            // Draw the current piece
            if (currentPiece) {
                for (let r = 0; r < currentPiece.shape.length; r++) {
                    for (let c = 0; c < currentPiece.shape[r].length; c++) {
                        if (currentPiece.shape[r][c]) {
                            drawBlock(currentPiece.x + c, currentPiece.y + r, currentPiece.color);
                        }
                    }
                }
            }
        }

        function drawNextPiece() {
            nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
            nextCtx.fillStyle = 'rgba(31, 26, 51, 0.8)';
            nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);

            if (nextPiece) {
                const shape = nextPiece.shape;
                const offsetX = (NEXT_PREVIEW_SIZE - shape[0].length) / 2;
                const offsetY = (NEXT_PREVIEW_SIZE - shape.length) / 2;
                
                for (let r = 0; r < shape.length; r++) {
                    for (let c = 0; c < shape[r].length; c++) {
                        if (shape[r][c]) {
                            drawBlock(
                                (c + offsetX) * BLOCK_SIZE / BLOCK_SIZE * 1, // Normalized X position
                                (r + offsetY) * BLOCK_SIZE / BLOCK_SIZE * 1, // Normalized Y position
                                nextPiece.color,
                                nextCtx // Use nextCtx for the next piece canvas
                            );
                        }
                    }
                }
            }
        }


        function checkCollision(newX, newY, newShape) {
            for (let r = 0; r < newShape.length; r++) {
                for (let c = 0; c < newShape[r].length; c++) {
                    if (newShape[r][c]) {
                        const boardX = newX + c;
                        const boardY = newY + r;

                        // Check boundaries
                        if (boardX < 0 || boardX >= COLS || boardY >= ROWS) {
                            return true; 
                        }
                        
                        // Check collision with existing blocks (ignore blocks above the board)
                        if (boardY >= 0 && board[boardY][boardX]) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function lockPiece() {
            for (let r = 0; r < currentPiece.shape.length; r++) {
                for (let c = 0; c < currentPiece.shape[r].length; c++) {
                    if (currentPiece.shape[r][c]) {
                        const boardX = currentPiece.x + c;
                        const boardY = currentPiece.y + r;
                        
                        // Only lock pieces that are on the board (y >= 0)
                        if (boardY >= 0) {
                            board[boardY][boardX] = currentPiece.color;
                        }
                    }
                }
            }
            checkLines();
            currentPiece = null;
            
            // Check for game over condition (piece locked at or above the top row)
            for (let c = 0; c < COLS; c++) {
                if (board[0][c]) {
                    gameOver();
                    return;
                }
            }
        }

        function checkLines() {
            let linesCleared = 0;
            for (let r = ROWS - 1; r >= 0; r--) {
                if (board[r].every(cell => cell !== 0)) {
                    // Line is full, remove it
                    board.splice(r, 1);
                    // Add a new empty row at the top
                    board.unshift(Array(COLS).fill(0));
                    linesCleared++;
                    r++; // Recheck the current row index, since a new row shifted down
                }
            }
            
            if (linesCleared > 0) {
                updateScore(linesCleared);
            }
        }
        
        function rotateMatrix(matrix) {
            const N = matrix.length - 1;
            const result = matrix.map((row, i) =>
                row.map((val, j) => matrix[N - j][i])
            );
            return result;
        }

        function tryMove(dx, dy, newShape = currentPiece.shape) {
            const newX = currentPiece.x + dx;
            const newY = currentPiece.y + dy;

            if (!checkCollision(newX, newY, newShape)) {
                currentPiece.x = newX;
                currentPiece.y = newY;
                return true;
            }
            return false;
        }
        
        function tryRotate() {
            const originalShape = currentPiece.shape;
            const newShape = rotateMatrix(originalShape);

            // Simple wall kick mechanism: try to shift X position if rotation causes collision
            const offsets = [
                [0, 0],     // No kick
                [-1, 0],    // Kick left
                [1, 0],     // Kick right
                [0, -1],    // Kick up
            ];

            for (const [dx, dy] of offsets) {
                if (!checkCollision(currentPiece.x + dx, currentPiece.y + dy, newShape)) {
                    currentPiece.x += dx;
                    currentPiece.y += dy;
                    currentPiece.shape = newShape;
                    return true;
                }
            }

            return false; // Rotation failed
        }


        // --- GAME LOGIC ---

        function updateScore(linesCleared) {
            const baseScore = SCORE_PER_LINE[linesCleared];
            score += baseScore * level;
            lines += linesCleared;
            
            // Level up check
            const newLevel = Math.floor(lines / LINES_PER_LEVEL) + 1;
            if (newLevel > level) {
                levelUp(newLevel);
            }
            
            document.getElementById('score').textContent = score;
            document.getElementById('lines').textContent = lines;

            // Check and update high score immediately
            updateUserHighScore(score);
        }
        
        function levelUp(newLevel) {
            level = newLevel;
            document.getElementById('level').textContent = level;
            showMessage(`LEVEL UP! Level ${level}!`, 'success');
            
            // Adjust game speed (1000ms - (level-1) * 50ms, minimum 100ms)
            // Note: In the requestAnimationFrame loop (gameTick), the speed is controlled by dropInterval()
            // The interval change only needs to happen implicitly via the dropInterval function.
        }

        function dropPiece() {
            if (!currentPiece) return;

            if (tryMove(0, 1)) {
                // Moved down successfully
            } else {
                // Cannot move down, lock the piece
                lockPiece();
                if (!isGameOver) {
                    spawnNewPiece();
                }
            }
        }
        
        function spawnNewPiece() {
            currentPiece = nextPiece;
            nextPiece = randomPiece();
            drawNextPiece();
            
            // Check for instant game over upon spawning
            if (checkCollision(currentPiece.x, currentPiece.y, currentPiece.shape)) {
                gameOver();
            }
        }

        let lastTime = 0;
        let dropCounter = 0;
        const dropInterval = () => Math.max(100, 1000 - (level - 1) * 50); // Speed based on level

        function gameTick(time = 0) {
            if (isPaused || isGameOver) return;

            const deltaTime = time - lastTime;
            lastTime = time;
            dropCounter += deltaTime;

            if (dropCounter > dropInterval()) {
                dropPiece();
                dropCounter = 0;
            }
            
            drawBoard();
            
            // Request the next frame for smooth animation
            gameLoop = requestAnimationFrame(gameTick);
        }

        function togglePause() {
            if (isGameOver) return;
            isPaused = !isPaused;
            const pauseButton = document.getElementById('pauseButton');
            
            if (isPaused) {
                pauseButton.textContent = 'RESUME GAME';
                showMessage('Game Paused', 'error');
                if (gameLoop) cancelAnimationFrame(gameLoop); // Stop RAF loop
            } else {
                pauseButton.textContent = 'PAUSE GAME';
                showMessage('Game Resumed', 'success');
                lastTime = performance.now(); // Reset lastTime to prevent sudden drops
                requestAnimationFrame(gameTick); // Resume the RAF loop
            }
        }

        function gameOver() {
            isGameOver = true;
            if (gameLoop) cancelAnimationFrame(gameLoop);
            showMessage(`GAME OVER! Final Score: ${score}`, 'error', true);
            
            document.getElementById('startButton').classList.remove('hidden');
            document.getElementById('pauseButton').classList.add('hidden');

            // Final check and update of high score (if it hasn't been done already)
            updateUserHighScore(score);
            updateGlobalLeaderboard(score);
        }

        // --- INPUT HANDLING ---
        document.addEventListener('keydown', (event) => {
            if (isPaused || isGameOver || !currentPiece) return;

            switch (event.key) {
                case 'ArrowLeft':
                case 'a':
                    tryMove(-1, 0);
                    break;
                case 'ArrowRight':
                case 'd':
                    tryMove(1, 0);
                    break;
                case 'ArrowDown':
                case 's':
                    dropPiece(); // Soft drop: instant drop, but maintains interval
                    dropCounter = 0; // Reset counter for quicker next drop
                    break;
                case 'ArrowUp':
                case 'w':
                    tryRotate();
                    break;
                case ' ': // Space for hard drop
                    while (tryMove(0, 1)) { /* keep moving down */ }
                    lockPiece();
                    // The lockPiece function checks for game over, so we only spawn if not over
                    if (!isGameOver) { 
                        spawnNewPiece();
                    }
                    break;
                case 'p':
                case 'P':
                    togglePause();
                    break;
            }
            drawBoard();
        });


        // --- UI & EVENT HANDLERS ---
        // These handlers are now registered inside the window.onload/DOMContentLoaded event.

        function showMessage(text, type = 'success', sticky = false) {
            const box = document.getElementById('messageBox');
            box.textContent = text;
            box.className = `message-box show ${type}`;
            
            if (!sticky) {
                setTimeout(() => {
                    box.classList.remove('show');
                }, 3000);
            }
        }

        // --- FIREBASE / DATA PERSISTENCE ---

        async function initializeFirebase() {
            // Check if we are using the placeholder config and notify if so
            if (!isFirebaseConfigValid) {
                 console.warn("Using PLACEHOLDER Firebase configuration. High scores will NOT persist to a real backend. Only Local Storage will be used.");
                 showMessage("WARNING: Firebase Config Invalid. Scores will only save locally.", 'error', true);
                 updateAuthUI(false); // Force Logged Out state
                 listenForUserHighScore(); // Start local storage listener
                 return; // Stop Firebase initialization
            }

            try {
                const app = window.initializeFirebaseApp(firebaseConfig);
                db = window.firebaseGetFirestore(app);
                auth = window.getFirebaseAuth(app);
                // window.firebaseSetLogLevel('debug'); // Removed unnecessary logging

                // 1. Initial Authentication Attempt (Custom Token -> Anonymous Fallback)
                let authResult;

                if (initialAuthToken) {
                    try {
                        authResult = await window.firebaseSignInWithCustomToken(auth, initialAuthToken);
                        console.log("Signed in with Custom Token successfully.");
                    } catch (error) {
                        console.warn("Custom Token sign-in failed. Falling back to anonymous. Error:", error.message);
                    }
                }
                
                if (!authResult) {
                    try {
                        // If token failed or was missing, try anonymous sign-in
                        authResult = await window.firebaseSignInAnonymously(auth);
                        console.log("Signed in anonymously successfully.");
                    } catch (error) {
                        const message = error.message.replace('Firebase: Error (auth/', '').replace(').', '').replace(')', '');
                        console.error("Anonymous sign-in failed:", error);
                        // Only show message if the error is due to an invalid API key
                        if (error.message.includes('api-key-not-valid')) {
                           showMessage(`Authentication failed: ${message}. Please check your API key in the script.`, 'error', true);
                        }
                        updateAuthUI(false);
                        userId = null;
                        return; // Stop if core auth fails
                    }
                }
                
                // 2. Set up State Change Listener and Finalize Setup
                // This listener handles subsequent sign-outs/logins and the initial state once settled
                window.onFirebaseAuthStateChanged(auth, (authUser) => {
                    if (authUser) {
                        userId = authUser.uid;
                        // Start data listeners and update UI once the user is definitively logged in
                        handleAuthentication(authUser.isAnonymous); 
                    } else {
                        // User logged out, reset state and try to sign in anonymously again
                        console.log("User logged out, re-signing in anonymously.");
                        userId = null;
                        updateAuthUI(false);
                        window.firebaseSignInAnonymously(auth).catch(e => {
                            console.error("Failed to re-sign in anonymously:", e);
                            showMessage("Session expired. Please log in.", 'error', true);
                        });
                    }
                });

            } catch (e) {
                console.error("Firebase initialization error:", e);
                showMessage(`Failed to connect to the database. Error: ${e.message}`, 'error', true);
            }
        }
        
        function handleAuthentication(isAnonymous) {
            const isGuestSession = isAnonymous;
            console.log(`User authenticated. UID: ${userId}, Is Guest: ${isGuestSession}`);
            
            // Update UI based on authentication status
            updateAuthUI(!isGuestSession);

            // Start Firestore Listeners only after auth is complete
            if (db && userId) {
                listenForUserHighScore();
                listenForGlobalLeaderboard();
            } else if (!db) {
                console.error("Firestore database object (db) is null. Cannot start listeners.");
            }
        }
        
        function updateAuthUI(isAuthenticated) {
            const statusText = document.getElementById('authStatusText');
            const userIdDisplay = document.getElementById('userIdDisplay');
            const loginModalButton = document.getElementById('loginModalButton');
            const logoutButton = document.getElementById('logoutButton');

            if (!isFirebaseConfigValid) {
                statusText.textContent = 'LOCAL ONLY';
                statusText.classList.remove('text-green-400', 'text-yellow-400');
                statusText.classList.add('text-red-400');
                userIdDisplay.textContent = 'Local Storage';
                loginModalButton.classList.add('hidden');
                logoutButton.classList.add('hidden');
                return;
            }

            if (isAuthenticated) {
                statusText.textContent = 'Account Logged In';
                statusText.classList.remove('text-red-400', 'text-yellow-400');
                statusText.classList.add('text-green-400');
                loginModalButton.classList.add('hidden');
                logoutButton.classList.remove('hidden');
            } else if (userId) {
                statusText.textContent = 'Guest Session';
                statusText.classList.remove('text-green-400', 'text-red-400');
                statusText.classList.add('text-yellow-400');
                loginModalButton.classList.remove('hidden');
                logoutButton.classList.add('hidden'); // Show login button if user is anonymous
            } else {
                statusText.textContent = 'Logged Out';
                statusText.classList.remove('text-green-400', 'text-yellow-400');
                statusText.classList.add('text-red-400');
                loginModalButton.classList.remove('hidden');
                logoutButton.classList.add('hidden'); // Should only show login button
            }
            userIdDisplay.textContent = userId || 'N/A';
        }

        // --- AUTH FORMS ---

        async function handleSignUp(event) {
            event.preventDefault();
            const email = document.getElementById('signUpEmail').value;
            const password = document.getElementById('signUpPassword').value;
            const authMessage = document.getElementById('authMessage');

            try {
                await window.firebaseCreateUserWithEmailAndPassword(auth, email, password);
                authMessage.textContent = "Sign up successful! Logged in.";
                authMessage.className = "text-green-400 bg-green-900/50 text-center py-2 mb-4 rounded";
                authMessage.classList.remove('hidden');
                document.getElementById('authModal').classList.add('hidden');
            } catch (error) {
                console.error("Sign Up Error:", error);
                authMessage.textContent = `Sign Up Failed: ${error.message.replace('Firebase: Error (auth/', '').replace(').', '').replace(')', '')}`;
                authMessage.className = "text-red-400 bg-red-900/50 text-center py-2 mb-4 rounded";
                authMessage.classList.remove('hidden');
            }
        }

        async function handleLogin(event) {
            event.preventDefault();
            const email = document.getElementById('loginEmail').value;
            const password = document.getElementById('loginPassword').value;
            const authMessage = document.getElementById('authMessage');

            try {
                await window.firebaseSignInWithEmailAndPassword(auth, email, password);
                authMessage.textContent = "Log in successful!";
                authMessage.className = "text-green-400 bg-green-900/50 text-center py-2 mb-4 rounded";
                authMessage.classList.remove('hidden');
                document.getElementById('authModal').classList.add('hidden');
            } catch (error) {
                console.error("Log In Error:", error);
                authMessage.textContent = `Login Failed: ${error.message.replace('Firebase: Error (auth/', '').replace(').', '').replace(')', '')}`;
                authMessage.className = "text-red-400 bg-red-900/50 text-center py-2 mb-4 rounded";
                authMessage.classList.remove('hidden');
            }
        }
        
        async function handleSignOut() {
            try {
                // Sign out will trigger the onAuthStateChanged listener, 
                // which will then show the user as logged out.
                await window.firebaseSignOut(auth);
                // The onAuthStateChanged listener handles the subsequent anonymous sign-in and UI update.
                showMessage("Logged out successfully.", 'success');
            } catch (error) {
                console.error("Sign Out Error:", error);
                showMessage("Logout failed.", 'error');
            }
        }
        
        // --- LOCAL STORAGE FALLBACK FUNCTIONS ---
        const LOCAL_HIGH_SCORE_KEY = 'tetris_high_score';

        function loadLocalHighScore() {
            const storedScore = localStorage.getItem(LOCAL_HIGH_SCORE_KEY);
            return storedScore ? parseInt(storedScore, 10) : 0;
        }

        function saveScoreLocally(score) {
            const currentLocalScore = loadLocalHighScore();
            if (score > currentLocalScore) {
                localStorage.setItem(LOCAL_HIGH_SCORE_KEY, score);
                document.getElementById('userHighScore').textContent = score.toLocaleString();
                console.log(`Local high score updated to: ${score}`);
            }
        }

        // --- HIGH SCORE / LEADERBOARD LOGIC ---

        // Function to listen for the current user's high score
        function listenForUserHighScore() {
            const userHighScoreElement = document.getElementById('userHighScore');

            if (!isFirebaseConfigValid || !db || !userId) {
                // FALLBACK: Load from Local Storage
                const localScore = loadLocalHighScore();
                userHighScoreElement.textContent = localScore.toLocaleString();
                console.warn("Using local storage for high score.");
                return; 
            }

            // Path: /artifacts/{appId}/users/{userId}/highscores/tetris
            const docRef = window.firebaseDoc(db, 'artifacts', appId, 'users', userId, 'highscores', 'tetris');
            
            return window.firebaseOnSnapshot(docRef, (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    const highscore = data.score || 0;
                    userHighScoreElement.textContent = highscore.toLocaleString();
                    saveScoreLocally(highscore); // Keep local storage synced as a backup
                } else {
                    // If no Firestore score, check local storage
                    const localScore = loadLocalHighScore();
                    userHighScoreElement.textContent = localScore.toLocaleString();
                    console.log("No personal high score found on Firestore. Displaying local score.");
                }
            }, (error) => {
                console.error("Error listening to user high score:", error);
                // On error, try to fall back to local storage display
                const localScore = loadLocalHighScore();
                userHighScoreElement.textContent = localScore.toLocaleString();
                showMessage("Failed to load online high score. Displaying local score.", 'error');
            });
        }
        
        // Function to update user's high score if the current score is greater
        async function updateUserHighScore(currentScore) {
            saveScoreLocally(currentScore); // Always save to local storage

            if (!isFirebaseConfigValid || !db || !userId) {
                console.warn("Cannot update online high score: Firebase not available or User ID not set.");
                return;
            }
            
            // Path: /artifacts/{appId}/users/{userId}/highscores/tetris
            const docRef = window.firebaseDoc(db, 'artifacts', appId, 'users', userId, 'highscores', 'tetris');
            
            try {
                // We use setDoc with merge: true to update or create the document
                await window.firebaseSetDoc(docRef, { 
                    score: currentScore,
                    lastPlayed: new Date().toISOString()
                }, { merge: true });
                // Note: The listener (listenForUserHighScore) will automatically update the UI
            } catch (error) {
                console.error("Error saving user high score to Firestore:", error);
                // Do not show an error to the user for a benign high score save failure
            }
        }
        
        // Function to update the global leaderboard if the current score is high enough
        async function updateGlobalLeaderboard(currentScore) {
            if (!isFirebaseConfigValid || !db || !userId || !auth.currentUser || auth.currentUser.isAnonymous) {
                // Only update global leaderboard for non-anonymous users
                console.log("Global leaderboard update skipped (Guest session or Firebase not ready).");
                return;
            }
            
            // Global Path: /artifacts/{appId}/public/data/leaderboard/{userId}
            const docRef = window.firebaseDoc(db, 'artifacts', appId, 'public', 'data', 'leaderboard', userId);
            const userEmail = auth.currentUser.email || 'Player ' + userId.substring(0, 4);

            try {
                // Set the global high score record
                await window.firebaseSetDoc(docRef, { 
                    score: currentScore,
                    userId: userId,
                    email: userEmail,
                    lastUpdated: new Date().toISOString()
                }, { merge: true });
                console.log(`Global leaderboard updated for user: ${userId} with score: ${currentScore}`);
            } catch (error) {
                console.error("Error saving global high score:", error);
            }
        }

        // Function to listen for the global leaderboard and display it
        function listenForGlobalLeaderboard() {
            if (!isFirebaseConfigValid || !db) {
                console.warn("Database not ready for global leaderboard listener. Showing 'N/A'.");
                document.getElementById('leaderboardList').innerHTML = '<li class="text-center text-gray-400">Online leaderboard not available.</li>';
                document.getElementById('globalTopScore').textContent = 'N/A';
                return;
            }
            
            // Global Path: /artifacts/{appId}/public/data/leaderboard
            const leaderboardCollectionRef = window.firebaseCollection(db, 'artifacts', appId, 'public', 'data', 'leaderboard');
            
            // Create a query to get the top 10 scores
            // NOTE: orderBy is used here, but for real production, security rules may require indexes.
            const q = window.firebaseQuery(
                leaderboardCollectionRef,
                window.firebaseOrderBy('score', 'desc'),
                window.firebaseLimit(10)
            );

            return window.firebaseOnSnapshot(q, (snapshot) => {
                const leaderboardList = document.getElementById('leaderboardList');
                const globalTopScoreElement = document.getElementById('globalTopScore');
                leaderboardList.innerHTML = '';
                let topScore = 0;
                
                if (snapshot.empty) {
                    leaderboardList.innerHTML = '<li class="text-center text-gray-400">No scores yet!</li>';
                    globalTopScoreElement.textContent = 'N/A';
                    return;
                }

                snapshot.forEach((doc, index) => {
                    const data = doc.data();
                    const score = data.score || 0;
                    const email = data.email || 'Guest';
                    
                    if (index === 0) {
                        topScore = score;
                        globalTopScoreElement.textContent = score.toLocaleString();
                    }
                    
                    const listItem = document.createElement('li');
                    listItem.className = 'flex justify-between items-center px-2 py-1 rounded ' + 
                                        (doc.id === userId ? 'bg-orange-600 font-bold text-white shadow-lg' : 'hover:bg-indigo-700 transition');
                    
                    const rank = index + 1;
                    // Truncate email for display, especially if logged in as guest with complex UID
                    const displayEmail = doc.id === userId ? 'YOU' : email.split('@')[0];

                    listItem.innerHTML = `
                        <span class="w-1/6">${rank}.</span>
                        <span class="w-3/6 truncate">${displayEmail}</span>
                        <span class="w-2/6 text-right">${score.toLocaleString()}</span>
                    `;
                    leaderboardList.appendChild(listItem);
                });
            }, (error) => {
                console.error("Error listening to global leaderboard:", error);
                document.getElementById('leaderboardList').innerHTML = '<li class="text-center text-red-400">Failed to load scores.</li>';
            });
        }


        // --- UI Modal Handlers ---
        const authModal = document.getElementById('authModal');
        const loginForm = document.getElementById('loginForm');
        const signUpForm = document.getElementById('signUpForm');
        const authModalTitle = document.getElementById('authModalTitle');
        const authMessage = document.getElementById('authMessage');

        // --- INITIALIZATION ---
        window.onload = function() {
            // Initial game setup
            board = createBoard();
            nextPiece = randomPiece(); // Initialize next piece for preview
            drawBoard();
            drawNextPiece();
            
            // Initialize Firebase first
            initializeFirebase().then(() => {
                // After Firebase successfully initializes and auth state is checked
                // Ensure UI reflects current status
                if (auth) {
                    const isGuestSession = auth.currentUser ? auth.currentUser.isAnonymous : true;
                    updateAuthUI(!isGuestSession); 
                }
            }).catch(e => {
                console.error("Initialization failed:", e);
                // Fallback UI update if initialization completely failed
                updateAuthUI(false);
            });
            
            // Set up UI Event Handlers
            document.getElementById('startButton').addEventListener('click', startGame);
            document.getElementById('restartButton').addEventListener('click', startGame);
            document.getElementById('pauseButton').addEventListener('click', togglePause);

            document.getElementById('loginModalButton').addEventListener('click', () => {
                // Only show auth modal if config is valid
                if (!isFirebaseConfigValid) {
                    showMessage("Cannot log in/sign up. Firebase configuration is invalid.", 'error');
                    return;
                }
                loginForm.classList.remove('hidden');
                signUpForm.classList.add('hidden');
                authModalTitle.textContent = 'Log In';
                authModal.classList.remove('hidden');
                authMessage.classList.add('hidden');
            });

            document.getElementById('closeAuthModal').addEventListener('click', () => {
                authModal.classList.add('hidden');
            });
            
            document.getElementById('switchToSignUp').addEventListener('click', () => {
                loginForm.classList.add('hidden');
                signUpForm.classList.remove('hidden');
                authModalTitle.textContent = 'Create Account';
                authMessage.classList.add('hidden');
            });
            
            document.getElementById('switchToLogin').addEventListener('click', () => {
                loginForm.classList.remove('hidden');
                signUpForm.classList.add('hidden');
                authModalTitle.textContent = 'Log In';
                authMessage.classList.add('hidden');
            });
            
            // Submission handlers
            document.getElementById('signUpSubmit').addEventListener('click', handleSignUp);
            document.getElementById('loginSubmit').addEventListener('click', handleLogin);
            document.getElementById('logoutButton').addEventListener('click', handleSignOut);
        };


    </script>
</body>
</html>
